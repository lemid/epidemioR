# Estudos de sensibilidade de patógenos

## Introdução



## Ensaios de sensibilidade com *Phakopsora pachyrhizi*


```{r, image1, echo = FALSE, fig1 = '(ref:fig1)'}
knitr::include_graphics("./Alexandre/fig1.jpg")
```

### Estimando a EC50 com o pacote NLME

O exemplo a seguir utiliza um script desenvolvido para estimar a EC50 de 6 diferentes populações de *P. pachyrhizi*. Cada um dos isolados foi testado com 8 concentrações (0; 0,05; 0,5; 1; 5; 15; 50; 100 mg L^-1) de um fungicida. O experimento foi realizado em esquema fatorial 6X8 em delineamento inteiramente casualizado com 4 repetições.
O script demanda da instalação dos pacotes nlme, tidyverse e ggplot2. Os procedimentos a seguir apontam os comando necessários para o procedimento. A instalação dos pacotes será necessário ser realiza somente uma vez.

```{r, message=TRUE}
### Carregar os pacotes
library(nlme)
library(tidyverse)
library(ggplot2)
```

Os dados foram organizados em uma planilha em formato .csv. A primeira coluna denominada "trat"" continha os tratamentos avaliados no fator 1. Nesse caso, 6 populações do patógeno. Na segunda coluna, denominada como "conc", estavam descritas as concentrações testadas. Na terceira coluna foi expressa a variável resposta denominada "inib", correspondendo a inibição em relação a média da testemunha. A inibição foi calculada utilizando a equação :

Os dados importados para o R serão salvos em uma dataframe denominado "tb"
```{r}
### Selecionar o diretório
setwd("E:/Orientações e colaborações/Alexandre Claus/EpidemioR")

### Importar os dados do arquivo .csv para o R
tb <- read.csv2("dados.csv", dec=",", header = T)

### Explorar os dados dentro de "tb"
str(tb)
summary(tb)

### Plotar as curvas
ggplot(tb,
       aes(x = conc, y = inib)) +
  facet_wrap(facets = ~trat) +
  geom_point()
```

Nesse exemplo, iremos testar o ajuste dos dados aos modelos não lineares de curvas sigmoidais Gompertz e Weibull. 
O modelo de gompertz é expresso pela equação:

A equação que descreve o modelo de Weibull é expressa como:

```{r}
# modelo para a curva de secagem.
gompertz <- inib ~ A * exp(-exp(-C * (conc - B)))
```

O ajuste os dados nesse modelo utilizando o pacote nlme demanda de estimativas iniciais para os parametros, que aqui chamamos de "chutes iniciais". Esses "chutes" correspondem a assintota máxima da curva (A), o ponto de inflexão da curva (B) e a taxa (C). Para facilitar os chutes iniciais, utilizaremos a função SSgompertz e nls do pacote nlme. Essas funções combinadas permitem estimar os valores dos parametros com um nível de tolerância, permitindo a inserção na função gnls.

```{r}
### Estima curvas para os dados
fit <- nls(inib ~ SSgompertz(conc, A, C, B), data=tb)

### Extrai os coeficientes das curvas
coef(fit)

### Expões o número de níveis que geram curvas
levels(tb$trat)
```

Os valores dos parametros estimados pela função nls serão utilizados na função gnls. Os valores de cada parametro serão repetidos o número de níveis - 1. Em nosso exemplo, os valores aproximados dos paramêtros foram de 94 para A, 0.9 para C e 3 para B. O número de níveis -1 é igul a 5.

```{r}
### Primeiro ajuste
m1 <- gnls(model = gompertz,
           data = tb,
           params = A + C + B ~ trat,
           start = c(94, rep(0, times = 5),
                     0.9, rep(0, times = 5),
                     3, rep(0, times = 5)))

### Extrair os coeficientes para confirmação
coef(m1)
```

A utilização dos "chutes" permitiu o primeiro ajuste dos dados no modelo. Entretanto, quando extraimos os valores dos parametros dos modelos para cada uma das curvas, observamos que os valores dos parametros não condizem com os valores que as curvas expressam. Ou seja, a assintota máxima é o ponto máximo da curva onde há a estabilização. Quando plotamos as curvas, observamos que a assintoma máxima é de aproximadamente 90%. Como nosso ajuste apontou valores do parametro A muito distantes de 90%, devemos realizar um novo ajuste. Nessa situação, utilizaremos novamente os chutes iniciais que utilizamos no primeiro ajuste. Nesse segundo ajuste, não iremos descontar um nível, e usaremos 6.

```{r}
### Segundo ajuste
m2 <- gnls(model = gompertz,
           data = tb,
           params = A + C + B ~ 0 + trat,
           start = c(rep(94, times = 6),
                     rep(0.9, times = 6),
                     rep(3, times = 6)))

### Extrair os coeficientes para confirmação
coef(m2)
```

O segundo ajuste apontou valores condizentes para os parâmetros. Para confirmar que atingimos um ajuste adequado, subtituiremos os valores de chutes iniciais pelos valores dos parametros para cada curva. Para facilitar a extração dos valores dos parametros, é possivel utilizar os comando abaixo para criar uma planilha .csv.

```{r}
### Extrair os coeficientes do ajuste
coef <- coef(m2) %>%
  as.data.frame() %>%
  rownames_to_column("trat")
```

Em posse dos dados para os parametros, podemos adicionar os valores correspondentes aos parametros.
```{r}
### Ajuste de confirmação
m3 <- gnls(model = gompertz,
           data = tb,
           params = A + C + B ~ 0 + trat,
           start = c(c(89.63710365,   # A curva 1
                       91.89463993,   # A curva 2
                       100.0719032,   # A curva 3
                       95.84832279,   # A curva 4
                       96.70003200,   # A curva 5
                       94.85787488),  # A curva 6
                     c(0.331140869,   # C curva 1
                       0.151275417,   # C curva 2
                       0.097928351,   # C curva 3
                       0.066329123,   # C curva 4
                       0.053513318,   # C curva 5
                       0.336356745),  # C curva 6
                     c(4.031951529,   # B curva 1
                       12.08791249,   # B curva 2
                       10.92397598,   # B curva 3
                       17.08819591,   # B curva 4
                       19.19180247,   # B curva 5
                       3.986938092))) # B curva 6

### Extrair os coeficientes para confirmação
coef(m3)

# Tabela com as estimativas dos parâmetros para cada curva
summary(m3)$tTable
```

Com o ajuste de confirmação, podemos observar que as novas estimativas para os parametros são muito proximas daquelas que obtivemos com o segunde ajuste. Com os dados ajustados ao modelo, podemos extrair os valores da curva do modelo e os resíduos dos dados em relação a curva do modelo. Os valores da curva do modelo e os resíduos serão acomodados no dataframe com os dados iniciais.

```{r}
### Resíduos e curva do modelo
tb$res <- residuals(m3)
tb$fit <- fitted(m3)

### Dataframe com os dados iniciais 
head(tb)

### Gráfico com os resíduos contra o tempo
ggplot(tb,
       aes(x = conc, y = res)) +
  facet_wrap(facets = ~trat) +
  geom_point()

### Gráfico com os resíduos contra os valores ajustados
ggplot(tb,
       aes(x = fit, y = res)) +
  facet_wrap(facets = ~trat) +
  geom_point()

### Gráfico de normalidade dos resíduos.
ggplot(tb,
       aes(sample = res)) +
  facet_wrap(facets = ~trat) +
  geom_qq()

```

```{r}
### Grid para a predição com bandas
conc_seq <- seq(0, 100, by = 0.5)
grid <- with(tb,
             expand.grid(conc = conc_seq,
                         trat = levels(trat)))

grid$fit <- predict(m3, newdata = grid)
head(grid)

### Para retornar a matriz gradiente para o vetor `conc`
partials <- deriv(gompertz[-2],
                  namevec = c("A", "C", "B"),
                  function.arg = function(conc, A, C, B) {
                    NULL
                  })

### Matriz com os parâmetros estimados po curva
params <- matrix(coef(m3),
                 ncol = 3,
                 dimnames = list(levels(tb$trat),
                                 c("A", "C", "B")))

### Lista de matrizes gradiente
grad <- sapply(levels(tb$trat),
               simplify = FALSE,
               FUN = function(trat) {
                 u <- do.call(partials,
                              args = c(list(conc = conc_seq),
                                       as.list(params[trat, ])))
                 u <- attr(u, "gradient")
                 colnames(u) <- sprintf("%s.trat%s",
                                        colnames(u),
                                        trat)
                 return(u)
               })

head(grad)

### Criação da matriz bloco diagonal e atribui os tratamentos
X <- as.matrix(Matrix::bdiag(grad))
colnames(X) <- c(sapply(grad, colnames))

### Troca colunas de lugar para corresponder com `vcov()`.
X <- X[, colnames(vcov(m3))]

### Calcula o erro padrão do valor predito e o intervalo de confiança
qtl <- qt(0.975, df = nrow(tb) - length(coef(m3)))
grid$se <- sqrt(diag(X %*% vcov(m3) %*% t(X)))
grid <- grid %>%
  mutate(lwr = fit - qtl * se,
         upr = fit + qtl * se)
```

A estimativa de EC50
```{r}
params <- params %>%
  as.data.frame() %>%
  rownames_to_column("trat")

head(params)

tb_params <- params%>%as.data.frame()%>%
  mutate(EC50 =  B - (log(-log(50/A))/C))

head(tb_params)
```

O coeficiente de determinação como já descrito anteriormente nesse capítulo, não é um inidicativo de ajuste confiável. Entretanto, sabemos que diversos periódicos e revisores insistem nesse dado. Nesse caso, podemos obter os valores de R^2 utilizando os comando abaixo:

```{r}
### Cálcula o R^2 e cria o data frame tb_R^2
tb_r2 <- tb %>%
  group_by(trat) %>%
  summarise(R2 = cor(inib, fit)^2)

### Insere o valor do R^2 na tabela de paramêtros
tb_params <- tb_params %>% inner_join(tb_r2)

### Confirmação da criação da coluna R2
head(tb_params)
```

A expressão gráfica dos resultados é uma ferramenta impressindivel para muitos casos, podendo ser a melhor maneira de expressar os resultados.
```{r}
### Legenda contendo o valor de R^2 e EC50 com duas casas decimais 
fmt <- "R2: %0.2f \n EC50: %0.2f"

### Plotar os dados em 6 gráficos
grafico <- ggplot(tb, aes(x = conc, y = inib)) +
  facet_wrap(facets = ~trat, nrow = 2) 

### Insere a curva do modelo
grafico <- grafico + geom_line(data = grid,
            mapping = aes(x = conc, y = fit))

### Insere o intervalo de confiança
grafico <- grafico + geom_ribbon(data = grid,
              inherit.aes = FALSE,
              mapping = aes(x = conc, ymin = lwr, ymax = upr),
              fill = "darkorange",
              alpha = 0.4) 

### Insere os pontos correspondentes aos dados
grafico <- grafico + geom_point(pch = 1)

### Insere a legenda
grafico <- grafico + geom_text(data = tb_params, 
                               mapping = aes(x = 100,
                                             y = 0,
                                             label = sprintf(fmt, R2, EC50)),
                               parse = FALSE,
                               size = 3,
                               hjust = 1,
                               vjust = 0)

### Insere os eixos e os títulos
grafico <- grafico + geom_hline(yintercept = 50,
                                lty = 3,
                                size = 0.5,
                                col = "darkorange") +
  scale_y_continuous(breaks = seq(0, 100, by = 20)) +
  scale_x_continuous(breaks = seq(0, 100, by = 20)) +
  labs(x = "Concentração",
       y = "Inibição (%)")

### Plota o gráfico
grafico
```

Os valores do parametros, R^2 e a estimativa do EC50 serão organizados no data frame tb_params. Esse data frame poderá ser exportado para um arquivo .csv para facilitar a manipulação.
```{r}
tb_params
```


## Ensaios de sensibilidade de patógenos hemibiotróficos e necrotróficos - Exemplo com *Monilinia fructicola*



## Ensaios de sensibilidade de nematoides - Exemplo com *Meloidogyne* spp.

### Motivação

Os nematoides são animais pertencentes ao filo Nematoda, que engloba cerca de 4000 espécies. São essencilamente aquáticos, podendo ser encontrados em todos os ecossistemas da terra. Um grupo desses animais são de extrema importância para os seres humanos, pois causam diversos prejuizos, parasitando plantas e animais. 

Na agricultura, os nematoides são extremamente importantes pois parasitam as raizes de plantas de interesse agrícola. Esse grupo de nematoides possuem em orgão destinado exclusivamente para se alimentar do protoplasto das células das plantas, o estilete. Esse orgão atua como uma agulha de uma seringa, que ao penetrar a célula vegetal, é capaz de sugar seu conteudo. Esse habito faz com que os nematoides sejam exclusivamente dependentes das plantas, toranando-os parasitas obrigatórios. Considerando a dependência nutricional dos nematoides fitoparasitas, podemos considera-los uma preucupação constante para a agricultura. Esses animais geram prejuízos anuais estimados em US$ 157 bilhões [@abad_etal_2008; @hassan_etal_2013; @singh_etal_2013] a US$ 358 bilhões [@abd_2014].

As espécies de nematoides que mais ocorrem no Brasil são *Heterodera glycines* Ichinohe, 1951, *Meloidogyne incognita* (Kofoid & White) Chitwood, 1949, *Meloidogyne javanica* (Treub, 1885) Chitwood, 1949, *Pratylenchus brachyurus* (Godfrey, 1929) Filipjev & S. Stekhoven, 1941 e *Rotylenchulus reniformis* Linford & Oliveira, 1940 [@dias_etal_2010; @franzener_etal_2005; @lobo_etal_2017; @mattos_etal_2016; @mazzetti_etal_2019; @miamoto_etal_2017; @miamoto_etal_2018]. 

A cultura das soja ocupa uma extensa área das terras cultiváveis do Brasil, cerca de XXXXXX milhões de ha [fao_2019]. Parte

Os nematoides do gênero *Meloidogyne* são endoparasitas e possuem a caracteristica marcante de causar galhas na raizes das plantas parasitadas. Essas galhas são causadas pela penetração do estilete dos juvenis nas células das raízes das plantas. Ao inserir o estilete, o nematoide inicia a alimentação e segrega substâncias que inibem a resposta da planta e induzem a formação do sítio de alimentação. Esse sítio de alimentação irá direcionar fotossimilados e nutrientes das células vizinhas para a célula que está sendo sugada pelo juvenil. Ao se alimentar, o juvenil se desenvolve e realiza as ecdises necessárias para seu desenvolvimento. Ao atingir o estágio adulto, a fêmea possuirá o corpo periforme (fom o formato de pêra) e produzirá uma massa de ovos que se acumula em uma matriz gelatinosa que em alguns casos poderá romper a parede da galha e ser exposta para fora das raízes da planta parasitada. Os ovos, cerca de 2000, irão iniciar um novo ciclo de parasitismo.

Os métodos de controle mais utilizados para o controle de nematoides no Brasil é o manejo integrado de pragas e o controle químico [@hassan_etal_2013]. O manejo integrado nem sempre é usado devido à complexidade da aplicação, e na opinião de alguns agricultores, os métodos alternativos podem não ser eficiente, tornando o controle químico com agrotóxicos a principal opção dos agricultores [@sharifzadeh_etal_2018]. Entretanto, a aplicação de agrotóxicos causa graves desequilíbrios ambientais [@carvalho_2017; @long_krupke_2016] e problemas de saúde nos seres humanos [@caldas_2016; @hendges_etal_2019]. Assim, métodos de controle menos agressivos a saúde e ao meio ambiente vem sendo estudados.


### Experimentos de CE_50 com nematoides

Os estudos de sensibilidade dos nematoides aos compostos e extratos é realizado por curvas de dose resposta. 

. Assim, determinando o efeito de dose-resposta, é possivel estimar a concentração eficiente para obter o controle desejado. Esses estudos são realizados utilizando gradientes de concentrações de produtos, nos quais as fases de vida do nematoide são expostos ao tratamento por determinado periodo de tempo. Esses experimentos são comumente chamados de testes de eclosão, testes de motilidade e mortalidade, teste de penetração de juvenis e testes de Reprodução (Fator de reprodução).

Os testes de dose-resposta são realizados ao menos com 5 tratamentos, cada um deles com uma concentração diferente do produto. Geralmente são adicionados tratamentos testemunhas, no qual a concentração do produto testado é 0%. Cada concentração vai gerar uma resposta, afim de obter uma curva de resposta. Èssa curva deve formar um gradiente, onde as respostas apresentem diferentes níveis. Quando as concentrações não representam um gradiente de resposta, a estimativa da concentração efetiva pode ser subestima ou superestimada.

```{r curvaexemplo, echo = FALSE, fig.cap = '(ref:curvaexemplo)'} 
knitr::include_graphics("./marlon/curvaexemplo.jpg")
```

A curva de resposta corresponde a uma curva sigmoidal típica. Frequentemente os experimentos de expression(CE_50) apresentam somente parte da curva total, onde pode ocorrer ajuste em modelos lineares. A curva de dose resposta geralmente utilizada em estudos de CE50 para nematoides é baseada na curva de dose resposta baseada em um estudo de Seefeldt et al. (1995).


$$
y = f(x) = C + \frac{D - C}{1 + exp\left [ b \left ( log ( x \right ) - log\left ( CE_{50} \right ) \right )]}
$$

Onde: C é o limite inferior da curva, D é limite superior, b é o "Slup" e CE_50 é a concentração capaz de inibir em 50% a atividade dos nematoides.


### Análise de Dose-Resposta no R

Os dados obtidos pelas avaliações de um experimento preisam ser tabuladas em uma planilha. A planilha precisará ser organizada em colunas, no qual a primeira coluna corresponde ao tratamento. Na segunda coluna, devem ser dispostos as rapetições ou blocos. As colunas posteriores correspondem a variável resposta, das quais podem ser tantas quanto for necessário. A planilha poderá ser salvo em .txt, .csv ou .xlsc. Em nosso exemplo usaremos um arquivo em formato .csv. O arquivo poderá ser criado utilizando o comando de salvar como em csv (separado por ponto e vírgula). 

A importação dos dados da planilha será realizada usando os comandos abaixo:

```{r}
# Importação dos dados.
setwd('C:/Users/agrom/Projects/repo/epidemioR/marlon')

# importar os dados para o R
tb <- read.csv2("mortalidade.csv")
# exibir os dados
head(tb)

knitr::kable(head(tb), caption = '(ref:script mortalidade)',
             digits = c(NA, 0, 0, 1, 1),
             align = c("ccccc"),
             row.names = FALSE)
```


A verificação do comportamento dos dados é importante para verificar a ocorrência de pontos fora da curva. Em nosso exemplo vamos plotar os dados em gráficos do estilo boxplot. Esse tipo de gráfico permitirá observar os dados, as médias e o desvio padrão correspondente a cada tratamento.
Os dados originais de mortalidade não serão utilizados para a estimativa de CE50. Entretanto, a verificação dos dados originais de mortalidade permitirão identificar pontos discordantes. 

```{r}
opts_chunk$set(eval = FALSE)
```

```{r gráfico-exploratório-mortalidade, echo=FALSE}
# gráfico exploratório dos dados de mortalidade
knitr::kable((with(tb, boxplot(mort ~ conc, xlab="Concentração do tratamento (%)", ylab="Mortalidade de J2s (%)", 
                     ylim=c(0,100), las=1, cex.axis=0.8, horizontal = F))), caption = '(ref:gráfico-exploratório-mortalidade)',
             digits = c(NA, 0, 0, 1, 1),
             align = c("ccccc"),
             row.names = FALSE)
```

Os dados corrigidos pela equação de SCHNEIDER-ORELLI, 1947 foram expressos na planilha na coluna corr. Após a correção pela equação, a mortalidade natural da testemunha é eliminada dos dados, deste modo, os valores da testemunha após a correção são valores próximos de 0 (zero).

```{r}
# gráfico exploratório dos dadosdados de mortalidade corrigidos
knitr::kable((with(tb, boxplot(corr ~ conc, xlab="Concentração do tratamento (%)", ylab="Mortalidade de J2s (%)", 
                     ylim=c(0,100), las=1, cex.axis=0.8, horizontal = F))), caption = '(ref:gráfico-exploratório-corrigido)',
             digits = c(NA, 0, 0, 1, 1),
             align = c("ccccc"),
             row.names = FALSE)
```

O teste de Bartlett é recomendável .
Existe homogeneidade entre as variâncias?
Se P>0.05 as variâncias são homogêneas
Se P<0.05 as variâncias não são homogêneas

```{r}
bartlett.test(residuals(aov(corr ~ bloco+conc, data=tb)) 
              ~ interaction(ordered(conc)), data=tb)
```

```{r}
par(mfrow=c(1,1), mar=c(4,4,2,2))
library(car)
qqPlot(rstudent(aov(corr ~ bloco+ordered(conc), data=tb)), 
       pch=19, ylab="Resíduos")
```

Os blocos tem efeito aditivo?
Se Tukey.p>0.05 o bloco tem efeito aditivo
Se Tukey.p<0.05 o bloco não tem efeito aditivo


O pacote DRC (Dose-Responde Curve)

Regressão não linear de com 4 parâmetros



Ajustando um modelo log-logístico de cinco parâmetros (f=1)
```{r}
mortalidade.m5 <- drm(corr ~ conc, data = mortalidade, fct = LL.5(fixed = c(NA, NA, NA, NA, 1)))
coef(mortalidade.m5)
# Intervalos de confiança para todos os parâmetros
confint(mortalidade.m5)
```


```{r}
# Calculando os valores de EC/ED
ec50 <- ED(mortalidade.m5, c(50))

# Obter o intervalo de confiança de 95%
ED(mortalidade.m5, c(50), interval = "delta")
```

Comparando o método delta e transformado reversamente
intervalos de confiança para valores ED
Ajustar log-logist de 5 parâmetros

```{r}
# Estimativa de corrição por dose
backfit(mortalidade.m5)
summary(mortalidade.m5)

# Gráfico dos resíduos
plot(fitted(mortalidade.m5), residuals(mortalidade.m5)) 
abline(h=0,col="red")

# Diagnóstico de modelo para modelos de dose-resposta não linear
hatvalues(mortalidade.m5)
cooks.distance(mortalidade.m5)
logLik(mortalidade.m5)
modelFit(mortalidade.m5)
```

Plotagem da curva de dose resposta

```{r}
#Plotagem da curva de dose resposta
plot(corr ~ conc, data = mortalidade, xlab = "Concentration (%)", ylab = "Inhibition of hatching (%)", 
     xlim=c(0, 0.8), ylim=c(-20, 120), las=1, log="", lwd=0, cex=1.5, cex.axis=2.8, cex.lab=2.8,
     pch=19)

# Plotando a curva de regressão ajustada
plot(mortalidade.m5, xlab = "Concentration (%)", ylab = "Inhibition of hatching (%)",
     xlim=c(0, 0.8), ylim=c(-20, 120), log="", lwd=2, cex=0, add=TRUE)
abline(v=0.345,h=50,col="blue")
# Adicionando intervalo de confiança
plot(mortalidade.m5, broken = FALSE, type="confidence", add=TRUE)

dev.off()
dev.off()

```
